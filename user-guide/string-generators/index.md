---
layout: user-guide
tagline: “Talking nonsense is the sole privilege mankind possesses over the other organisms. It's by talking nonsense that one gets to the truth! I talk nonsense, therefore I'm human” ― Fyodor Dostoyevsky
image: dice-splash
title: String Generators
---

#Fyodor User Guide - String Generators#

Fyodor's `StringGenerator` will, by default, return a `java.util.String` of 30 characters chosen 
from the following list:

{% highlight perl %}
!#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
{% endhighlight %}

e.g. running `RDG.string.next();` right now returns 

{% highlight bash %}
2LWKjDK1o6}@ps9P>!^`B/VEq@4}B7
{% endhighlight %}

on my machine.

You can change the length of the string generated by `StringGenerator` and also specify different sets of characters that the string is built up from.  As well as the basic `public static string` member that is the default generator mentioned above, these are the static methods available on RDG for returning a `StringGenerator`:

* `string(Integer)`
* `string(Integer, CharacterFilter)`
* `string(Integer, Range<Integer>)`
* `string(Integer, CharacterSetGenerator)`
* `string(Integer, Collection<Character>)`
* `string(Integer, Character[])`

All of which is a fancy way of saying that a `StringGenerator` is created with an array of characters from which it will return the same quantity of random-selected ones with each call to `next()`.

### `string(Integer, CharacterFilter)`

`CharacterFilter` is an interface which `StringGenerator` will apply to the default array of characters to decide which ones to include when creating its base array:

`public interface CharacterFilter {public boolean includeCharacter(int i);}`

There are 3 implementations of this in Fyodor that you can use: 

* `AllCharactersFilter` - returns true for everything (used as the default)
* `LettersAndDigitsFilter` - only returns true for letters and digits
* `LettersOnlyFilter` - only returns true for letters

or you can provide your own.

### `string(Integer, Range<Integer>)`

The `Range` here is a [`com.google.common.collect.Range`](https://code.google.com/p/guava-libraries/wiki/RangesExplained) from [Google's Guava library](https://code.google.com/p/guava-libraries/) which defines the range of `Integer`s to use as the source of characters.  The default is `Range.closed(33, 126)` which is the following:

<table>
<tr>
<th>33</th>
<th>34</th>
<th>35</th>
<th>36</th>
<th>37</th>
<th>38</th>
<th>39</th>
<th>40</th>
<th>41</th>
<th>42</th>
<th>43</th>
<th>44</th>
<th>45</th>
<th>46</th>
<th>47</th>
<th>48</th>
<th>49</th>
<th>50</th>
<th>51</th>
<th>52</th>
<th>53</th>
<th>54</th>
<th>55</th>
<th>56</th>
<th>57</th>
<th>58</th>
<th>59</th>
<th>60</th>
<th>61</th>
<th>62</th>
<th>63</th>
<th>64</th>
<th>65</th>
<th>66</th>
<th>67</th>
<th>68</th>
<th>69</th>
<th>70</th>
<th>71</th>
<th>72</th>
<th>73</th>
<th>74</th>
<th>75</th>
<th>76</th>
<th>77</th>
<th>78</th>
<th>79</th>
<th>80</th>
<th>81</th>
<th>82</th>
<th>83</th>
<th>84</th>
<th>85</th>
<th>86</th>
<th>87</th>
<th>88</th>
<th>89</th>
<th>90</th>
<th>91</th>
<th>92</th>
<th>93</th>
<th>94</th>
<th>95</th>
<th>96</th>
<th>97</th>
<th>98</th>
<th>99</th>
<th>100</th>
<th>101</th>
<th>102</th>
<th>103</th>
<th>104</th>
<th>105</th>
<th>106</th>
<th>107</th>
<th>108</th>
<th>109</th>
<th>110</th>
<th>111</th>
<th>112</th>
<th>113</th>
<th>114</th>
<th>115</th>
<th>116</th>
<th>117</th>
<th>118</th>
<th>119</th>
<th>120</th>
<th>121</th>
<th>122</th>
<th>123</th>
<th>124</th>
<th>125</th>
<th>126</th>
</tr>
<tr>
<td>!</td>
<td>"</td>
<td>#</td>
<td>$</td>
<td>%</td>
<td>&</td>
<td>'</td>
<td>(</td>
<td>)</td>
<td>*</td>
<td>+</td>
<td>,</td>
<td>-</td>
<td>.</td>
<td>/</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>:</td>
<td>;</td>
<td><</td>
<td>=</td>
<td>></td>
<td>?</td>
<td>@</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
<td>G</td>
<td>H</td>
<td>I</td>
<td>J</td>
<td>K</td>
<td>L</td>
<td>M</td>
<td>N</td>
<td>O</td>
<td>P</td>
<td>Q</td>
<td>R</td>
<td>S</td>
<td>T</td>
<td>U</td>
<td>V</td>
<td>W</td>
<td>X</td>
<td>Y</td>
<td>Z</td>
<td>[</td>
<td>\</td>
<td>]</td>
<td>^</td>
<td>_</td>
<td>`</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
<td>e</td>
<td>f</td>
<td>g</td>
<td>h</td>
<td>i</td>
<td>j</td>
<td>k</td>
<td>l</td>
<td>m</td>
<td>n</td>
<td>o</td>
<td>p</td>
<td>q</td>
<td>r</td>
<td>s</td>
<td>t</td>
<td>u</td>
<td>v</td>
<td>w</td>
<td>x</td>
<td>y</td>
<td>z</td>
<td>{</td>
<td>|</td>
<td>}</td>
<td>~</td>
</tr>
</table>

### `string(Integer, CharacterSetGenerator)`

A `CharacterSetGenerator` is a Fyodor class that takes a `Range` and a `CharacterFilter` in its constructor to generate the underlying `Character[]` array used by the `StringGenerator`.  You can experiment with creating your own `CharacterSetGenerator`s and calling `getCharset()` to see exactly what it's generated.

### `string(Integer, Collection<Character>)`
### `string(Integer, Character[])`

These are both convenience methods if you really want to go crazy if supplying your own `Range`, `CharacterFilter` or `CharacterSetGenerator` isn't enough.  They'll both just take the supplied `Character`s and use them as the underlying source.  You can call `Character[] getCharSet()` on any `StringGenerator` if it's easier to just fine tune the underlying charset of an existing generator (this returns a copy of the array used by the generator so you can add and remove characters without borking anything but it means you'll need to create a new generator to use it).